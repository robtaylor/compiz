<!--
  Compiz option code generator

  Copyright : (C) 2008 by Dennis Kasprzyk
  E-mail    : onestone@compiz-fusion.org
 
 
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output  method="text"/>

<!-- String conversion helper functions -->

    <xsl:template name="print">
        <xsl:param name="text"/>
	<xsl:value-of select="translate($text,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
    </xsl:template>

    <xsl:template name="PRINT">
        <xsl:param name="text"/>
	<xsl:value-of select="translate($text,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
    </xsl:template>

    <xsl:template name="Print">
        <xsl:param name="text"/>
	<xsl:call-template name="PRINT">
	    <xsl:with-param name="text">
		<xsl:value-of select="substring($text,1,1)"/>
	    </xsl:with-param>
	</xsl:call-template>
	<xsl:call-template name="print">
	    <xsl:with-param name="text">
		<xsl:value-of select="substring($text,2)"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:template>

    <xsl:template name="PrintCamel">
        <xsl:param name="text"/>
        <xsl:variable name="textconv">
            <xsl:value-of select="translate($text,' +-/\','_____')"/>
        </xsl:variable>
	<xsl:if test="string-length($textconv)">
	    <xsl:if test="contains($textconv,'_')">
		<xsl:call-template name="Print">
		    <xsl:with-param name="text">
			<xsl:value-of select="substring-before($textconv,'_')"/>
		    </xsl:with-param>
		</xsl:call-template>
		<xsl:call-template name="PrintCamel">
		    <xsl:with-param name="text">
			<xsl:value-of select="substring-after($textconv,'_')"/>
		    </xsl:with-param>
		</xsl:call-template>
	    </xsl:if>
	    <xsl:if test="not(contains($textconv,'_'))">
	       <xsl:call-template name="Print">
		    <xsl:with-param name="text">
			<xsl:value-of select="$textconv"/>
		    </xsl:with-param>
		</xsl:call-template>
	    </xsl:if>
	</xsl:if>
    </xsl:template>

    <xsl:template name="saveCName">
        <xsl:param name="text"/>
        <xsl:variable name="textFirst">
            <xsl:value-of select="translate(substring($text,1,1),'0123456789 +-','zottffssen___')"/>
        </xsl:variable>
        <xsl:value-of select="concat($textFirst,substring($text,2))"/>
    </xsl:template>

<!-- Plugin name variables -->

    <xsl:variable name="pName">
        <xsl:value-of select="/compiz/plugin[@useBcop = 'true']/@name"/>
    </xsl:variable>

    <xsl:variable name="pCName">
        <xsl:call-template name="saveCName">
	    <xsl:with-param name="text">
		<xsl:value-of select="$pName"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:variable>

    <xsl:variable name="plugin">
        <xsl:call-template name="print">
	    <xsl:with-param name="text">
		<xsl:value-of select="$pCName"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:variable>

    <xsl:variable name="Plugin">
        <xsl:call-template name="Print">
	    <xsl:with-param name="text">
		<xsl:value-of select="$pCName"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:variable>

    <xsl:variable name="PLUGIN">
        <xsl:call-template name="PRINT">
	    <xsl:with-param name="text">
		<xsl:value-of select="$pCName"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:variable>

<!-- global helper functions -->

    <xsl:template name="license">
<xsl:text>/*
 * This file is autogenerated with bcop:
 * The Compiz option code generator
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

</xsl:text>
    </xsl:template>

    <xsl:template name="printOptionsEnumName">
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::</xsl:text>
        <xsl:call-template name="PrintCamel">
	    <xsl:with-param name="text">
		<xsl:value-of select="@name"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:template>

    <xsl:template name="printOptionsEnumNamePure">
        <xsl:call-template name="PrintCamel">
	    <xsl:with-param name="text">
		<xsl:value-of select="@name"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:template>

    <xsl:template name="printOptionName">
        <xsl:call-template name="PrintCamel">
	    <xsl:with-param name="text">
		<xsl:value-of select="@name"/>
	    </xsl:with-param>
	</xsl:call-template>
    </xsl:template>
    
<!-- *** main block *** -->
    
    <xsl:template  match="/compiz">
        <xsl:if test="plugin[@useBcop = 'true']">
            <xsl:call-template name="hfile"/>
        </xsl:if>
    </xsl:template>

<!-- print get/set functions -->

    <xsl:template name="printFunctions">
        <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option">
            <xsl:choose>
                <xsl:when test="@type='int'">
                    <xsl:text>inline int
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().i ();
}

</xsl:text>
                </xsl:when>
                <xsl:when test="@type='float'">
                    <xsl:text>inline float
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().f ();
}

</xsl:text>
                </xsl:when>
                <xsl:when test="@type='bool'">
                    <xsl:text>inline bool
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().b ();
}

</xsl:text>
                </xsl:when>
                <xsl:when test="@type='string'">
                    <xsl:text>inline CompString
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().s ();
}

</xsl:text>
                </xsl:when>
                <xsl:when test="@type='match'">
                    <xsl:text>inline CompMatch &amp;
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().match ();
}

</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='color'">
                    <xsl:text>inline unsigned short *
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                                        <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().c ();
}

inline unsigned short
</xsl:text>
                    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Red ()
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().c ()[0];
}

inline unsigned short
</xsl:text>
                    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Green ()
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().c ()[1];
}


inline unsigned short
</xsl:text>
                    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Blue ()
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().c ()[2];
}


inline unsigned short
</xsl:text>
                    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Alpha ()
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().c ()[3];
}


</xsl:text>
                </xsl:when>
                <xsl:when test="@type='action' or @type='key' or @type='button' or @type='edge' or @type='bell'">
                    <xsl:text>inline CompAction &amp;
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().action ();
}

inline void
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::optionSet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Initiate (CompAction::CallBack init)
{
    mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().action ().setInitiate (init);
}

inline void
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::optionSet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Terminate (CompAction::CallBack term)
{
    mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().action ().setTerminate (term);
}

</xsl:text>
                </xsl:when>
                <xsl:when test="@type='list'">
                    <xsl:text>inline CompOption::Value::Vector &amp;
</xsl:text>
		    <xsl:value-of select="$Plugin"/>
		    <xsl:text>Options::</xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>
{
    return mOptions[</xsl:text>
                    <xsl:call-template name="printOptionsEnumName"/>
                    <xsl:text>].value ().list ();
}

</xsl:text>
                    <xsl:if test="./type[text() = 'int']/../desc/value">
                        <xsl:text>inline unsigned int
</xsl:text>
			<xsl:value-of select="$Plugin"/>
			<xsl:text>Options::optionGet</xsl:text>
			<xsl:call-template name="printOptionName"/>
			<xsl:text>Mask ()
{
    return m</xsl:text>
                    <xsl:call-template name="printOptionName"/>
                    <xsl:text>Mask;
}

</xsl:text>
                    </xsl:if>
                </xsl:when>
            </xsl:choose>

            <xsl:text>

inline void
</xsl:text>
	    <xsl:value-of select="$Plugin"/>
	    <xsl:text>Options::optionSet</xsl:text>
            <xsl:call-template name="printOptionName"/>
            <xsl:text>Notify (</xsl:text>
            <xsl:value-of select="$Plugin"/>
            <xsl:text>Options::ChangeNotify notify)
{
    mNotify[</xsl:text>
            <xsl:call-template name="printOptionsEnumName"/>
            <xsl:text>] = notify;
}

</xsl:text>
        </xsl:for-each>
    </xsl:template>

<!-- initialze option functions generation -->

    <xsl:template name="printOptionsInfo">
        <xsl:text>static const CompMetadata::OptionInfo </xsl:text>
        <xsl:value-of select="$plugin"/>
        <xsl:text>OptionsOptionInfo[] = {
</xsl:text>
        <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option">
            <xsl:call-template name="initOption"/>
        </xsl:for-each>
        <xsl:text>};

</xsl:text>
    </xsl:template>

    <xsl:template name="initOption">
        <xsl:text>    { "</xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>", "</xsl:text>
        <xsl:value-of select="@type"/>
        <xsl:text>", </xsl:text>
        <xsl:choose>
            <xsl:when test="(@type = 'int' or @type = 'float') and (./min/text() and ./max/text())">
                <xsl:text>"&lt;min&gt;</xsl:text>
                <xsl:value-of select="./min/text()"/>
                <xsl:text>&lt;/min&gt;&lt;max&gt;</xsl:text>
                <xsl:value-of select="./max/text()"/>
                <xsl:text>&lt;/max&gt;", </xsl:text>
            </xsl:when>
            <xsl:when test="@type = 'list' and ./type/text()">
                <xsl:text>"&lt;type&gt;</xsl:text>
                <xsl:value-of select="./type/text()"/>
                <xsl:text>&lt;/type&gt;", </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>0, </xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>0, 0 },
</xsl:text>
    </xsl:template>


<!-- set option function generation -->

    <xsl:template name="setOptions">
        <xsl:text>    CompOption   *o;
    unsigned int index;

    o = CompOption::findOption (mOptions, name, &amp;index);

    if (!o)
        return false;

    switch (index)
    {
</xsl:text>
        <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option">
            <xsl:call-template name="setOption"/>
        </xsl:for-each>
        <xsl:text>        default:
            break;
    }
    return false;
</xsl:text>
    </xsl:template>

    <xsl:template name="setOption">
        <xsl:text>        case </xsl:text>
        <xsl:call-template name="printOptionsEnumName"/>
        <xsl:text>:
            if (o->set (value))
            {
</xsl:text>
        <xsl:if test="@type = 'list' and ./desc/value and ./type/text() = 'int'">
            <xsl:text>                m</xsl:text>
            <xsl:call-template name="printOptionName"/>
            <xsl:text>Mask = 0;
                foreach (CompOption::Value &amp;val, o->value ().list ())
                    m</xsl:text>
            <xsl:call-template name="printOptionName"/>
        <xsl:text>Mask |= (1 &lt;&lt; val.i ());
</xsl:text>
        </xsl:if>
        <xsl:text>                if (!mNotify[</xsl:text>
        <xsl:call-template name="printOptionsEnumName"/>
        <xsl:text>].empty ())
                    mNotify[</xsl:text>
        <xsl:call-template name="printOptionsEnumName"/>
        <xsl:text>] (o, </xsl:text>
        <xsl:call-template name="printOptionsEnumName"/>
        <xsl:text>);
                return true;
            }
            break;
</xsl:text>
    </xsl:template>

<!-- *** header file generation *** -->

    <xsl:template name="hfile">
        <xsl:call-template name="license"/>
        <xsl:text>#ifndef _</xsl:text>
        <xsl:value-of select="$PLUGIN"/>
        <xsl:text>_OPTIONS_H
#define _</xsl:text>
        <xsl:value-of select="$PLUGIN"/>
        <xsl:text>_OPTIONS_H

#include &lt;core/core.h&gt;

</xsl:text>
        <xsl:call-template name="printClass"/>
        <xsl:text>

#endif
</xsl:text>
    </xsl:template>

<!-- enum for options -->

    <xsl:template name="printOptionsEnum">
<xsl:text>enum Options {
</xsl:text>
        <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option">
            <xsl:text>            </xsl:text>
            <xsl:call-template name="printOptionsEnumNamePure"/>
            <xsl:text>,
</xsl:text>
        </xsl:for-each>
        <xsl:text>            OptionNum
        };

</xsl:text>
    </xsl:template>


<!-- generate enums/masks for restricted string options -->

    <xsl:template name="printOptionEnums">
                <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option[(@type = 'int' or (@type = 'list' and ./type/text() = 'int')) and ./desc/value]">
            <xsl:text>        enum </xsl:text>
            <xsl:call-template name="printOptionName"/>
            <xsl:text> {
</xsl:text>
            <xsl:for-each select="desc/*[(name() = 'name' and not(@xml:lang)) or name() = '_name']">
                <xsl:text>            </xsl:text>
                <xsl:call-template name="PrintCamel">
		    <xsl:with-param name="text">
			<xsl:value-of select="../../@name"/>
		    </xsl:with-param>
		</xsl:call-template>
                <xsl:call-template name="PrintCamel">
		    <xsl:with-param name="text">
			<xsl:value-of select="text()"/>
		    </xsl:with-param>
	        </xsl:call-template>
	        <xsl:text> = </xsl:text>
	        <xsl:value-of select="../value/text()"/>
	        <xsl:text>,
</xsl:text>
            </xsl:for-each>
            <xsl:text>        };

</xsl:text>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="printOptionMasks">
        <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option[@type = 'list' and ./desc/value and ./type/text() = 'int']">
            <xsl:for-each select="desc/*[(name() = 'name' and not(@xml:lang)) or name() = '_name']">
                <xsl:text>        #define </xsl:text>
                <xsl:call-template name="PrintCamel">
		    <xsl:with-param name="text">
			<xsl:value-of select="../../@name"/>
		    </xsl:with-param>
		</xsl:call-template>
                <xsl:call-template name="PrintCamel">
		    <xsl:with-param name="text">
			<xsl:value-of select="text()"/>
		    </xsl:with-param>
	        </xsl:call-template>
	        <xsl:text>Mask (1 &lt;&lt; </xsl:text>
	        <xsl:value-of select="../value/text()"/>
	        <xsl:text>)
</xsl:text>
            </xsl:for-each>
            <xsl:text>

</xsl:text>
        </xsl:for-each>
    </xsl:template>

<!-- generate get/set function definitions -->

    <xsl:template name="printClass">
        <xsl:text>class </xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options {
    public:
        </xsl:text>
        <xsl:call-template name="printOptionsEnum"/>
        <xsl:call-template name="printOptionEnums"/>
        <xsl:call-template name="printOptionMasks"/>
        <xsl:text>        typedef boost::function &lt;void (CompOption *opt, Options num)&gt; ChangeNotify;

        </xsl:text>
	<xsl:value-of select="$Plugin"/>
        <xsl:text>Options (CompMetadata *);
        virtual ~</xsl:text>
	<xsl:value-of select="$Plugin"/>
        <xsl:text>Options ();

        virtual CompOption::Vector &amp; getOptions ();
        virtual bool setOption (const char *name, CompOption::Value &amp;value);

</xsl:text>
        <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option">
            <xsl:choose>
                <xsl:when test="@type='int'">
                    <xsl:text>        int </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
</xsl:text>
                </xsl:when>
                <xsl:when test="@type='float'">
                    <xsl:text>        float </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='bool'">
                    <xsl:text>        bool </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='string'">
                    <xsl:text>        CompString </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='match'">
                    <xsl:text>        CompMatch &amp; </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='color'">
                    <xsl:text>        unsigned short * </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
        unsigned short optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Red ();
        unsigned short optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Green ();
        unsigned short optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Blue ();
        unsigned short optionGet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Alpha ();
</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='action' or @type='key' or @type='button' or @type='edge' or @type='bell'">
                    <xsl:text>        CompAction &amp; </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
        void </xsl:text>
		    <xsl:text>optionSet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Initiate (CompAction::CallBack init);
        void </xsl:text>
		    <xsl:text>optionSet</xsl:text>
		    <xsl:call-template name="printOptionName"/>
		    <xsl:text>Terminate (CompAction::CallBack term);
</xsl:text>
                </xsl:when>
                 <xsl:when test="@type='list'">
                    <xsl:text>        CompOption::Value::Vector &amp; </xsl:text>
                    <xsl:call-template name="printGetFunctionDef"/>
                    <xsl:text>;
</xsl:text>
                    <xsl:if test="./type[text() = 'int']/../desc/value">
                        <xsl:text>        unsigned int optionGet</xsl:text>
			<xsl:call-template name="printOptionName"/>
			<xsl:text>Mask ();
</xsl:text>
                    </xsl:if>
                </xsl:when>
            </xsl:choose>
	    <xsl:text>        void optionSet</xsl:text>
            <xsl:call-template name="printOptionName"/>
            <xsl:text>Notify (ChangeNotify notify);

</xsl:text>
        </xsl:for-each>
        <xsl:text>
    protected:
        CompOption::Vector mOptions;

    private:
        std::vector&lt;ChangeNotify&gt; mNotify;
</xsl:text>
        <xsl:for-each select="plugin[@name=$pName]/descendant-or-self::option[@type = 'list' and ./desc/value and ./type/text() = 'int']">
        <xsl:text>        unsigned int m</xsl:text>
        <xsl:call-template name="printOptionName"/>
        <xsl:text>Mask;
</xsl:text>
        </xsl:for-each>
        <xsl:text>
};


</xsl:text>
        <xsl:call-template name="printOptionsInfo"/>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::</xsl:text>
	<xsl:value-of select="$Plugin"/>
        <xsl:text>Options (CompMetadata *metadata) :
    mOptions (</xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::OptionNum),
    mNotify (</xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::OptionNum)
{
    metadata->addFromOptionInfo (</xsl:text>
        <xsl:value-of select="$plugin"/>
        <xsl:text>OptionsOptionInfo, </xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::OptionNum);
    metadata->addFromFile ("</xsl:text>
        <xsl:value-of select="$plugin"/>
        <xsl:text>");
    metadata->initOptions (</xsl:text>
        <xsl:value-of select="$plugin"/>
        <xsl:text>OptionsOptionInfo, </xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::OptionNum, mOptions);

</xsl:text>
    <xsl:for-each select="/compiz/plugin[@name=$pName]/descendant-or-self::option">
        <xsl:if test="@type = 'list' and ./desc/value and ./type/text() = 'int'">
            <xsl:text>    m</xsl:text>
            <xsl:call-template name="printOptionName"/>
            <xsl:text>Mask = 0;
    foreach (CompOption::Value &amp;val, mOptions[</xsl:text>
            <xsl:call-template name="printOptionsEnumName"/>
            <xsl:text>].value ().list ())
        m</xsl:text>
            <xsl:call-template name="printOptionName"/>
        <xsl:text>Mask |= (1 &lt;&lt; val.i ());
</xsl:text>
        </xsl:if>
    </xsl:for-each>
        <xsl:text>
}

</xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::~</xsl:text>
	<xsl:value-of select="$Plugin"/>
        <xsl:text>Options ()
{
}

CompOption::Vector &amp;
</xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::getOptions ()
{
    return mOptions;
}

bool
</xsl:text>
        <xsl:value-of select="$Plugin"/>
        <xsl:text>Options::setOption (const char *name, CompOption::Value &amp;value)
{
</xsl:text>
        <xsl:call-template name="setOptions"/>
        <xsl:text>
}

</xsl:text><xsl:text>
</xsl:text>

    <xsl:call-template name="printFunctions"/>
    </xsl:template>

    <xsl:template name="printGetFunctionDef">
	<xsl:text>optionGet</xsl:text>
        <xsl:call-template name="printOptionName"/>
        <xsl:text> ()</xsl:text>
    </xsl:template>

</xsl:stylesheet>
